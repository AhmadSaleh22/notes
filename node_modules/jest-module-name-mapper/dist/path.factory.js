"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const base_url_factory_1 = require("./base-url.factory");
const tsconfig_paths_1 = require("tsconfig-paths");
const keyFactory = (key) => `^${key.replace(/\*/, '(.*)')}`;
const valueFactory = (values, baseUrl) => `${baseUrl}/${values[0].replace(/\*/, '$1')}`;
const connectPath = (path, baseUrl) => ({
    [keyFactory(path[0])]: valueFactory(path[1], baseUrl)
});
const convertToJestFormat = (result, item) => (Object.assign(Object.assign({}, result), item));
const pathFactory = (paths, baseUrl) => Object
    .entries(paths)
    .map(item => connectPath(item, baseUrl))
    .reduce(convertToJestFormat, {});
exports.moduleNameMapper = (path) => {
    const config = tsconfig_paths_1.loadConfig(path);
    if (config.resultType !== 'success') {
        console.error(chalk_1.default.red('[tsconfig.json] unable to load'));
        process.exit();
    }
    const { paths, baseUrl } = config;
    if (!paths || !baseUrl) {
        console.error(chalk_1.default.red('[tsconfig.json] "paths" or "baseUrl" field does not exist'));
        process.exit();
    }
    const transformedBaseUrl = base_url_factory_1.baseUrlFactory(baseUrl);
    return pathFactory(paths, transformedBaseUrl);
};
